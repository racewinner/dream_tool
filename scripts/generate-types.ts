/**
 * Type Generation Script
 * 
 * Generates TypeScript interface definitions from Sequelize models
 * to ensure frontend and backend type consistency.
 */

import * as fs from 'fs';
import * as path from 'path';
import { Model, ModelCtor } from 'sequelize';
import db from '../backend/src/models';

// Configuration
const CONFIG = {
  // Output directory for generated types
  outputDir: path.resolve(__dirname, '../frontend/src/types/generated'),
  
  // Header to include in generated files
  fileHeader: '/**\n * GENERATED FILE - DO NOT EDIT DIRECTLY\n * Generated by generate-types.ts\n */\n\n',
  
  // Models to exclude from generation
  excludeModels: ['SequelizeMeta'],
};

/**
 * Main function to generate types
 */
async function generateTypes() {
  console.log('Generating TypeScript interfaces from Sequelize models...');
  
  // Create output directory if it doesn't exist
  if (!fs.existsSync(CONFIG.outputDir)) {
    fs.mkdirSync(CONFIG.outputDir, { recursive: true });
  }
  
  // Get all model names
  const modelNames = Object.keys(db).filter(
    (key) => db[key]?.prototype instanceof Model && !CONFIG.excludeModels.includes(key)
  );
  
  console.log(`Found ${modelNames.length} models to process`);
  
  // Process each model
  for (const modelName of modelNames) {
    await generateModelInterface(modelName, db[modelName]);
  }
  
  // Generate index file
  generateIndexFile(modelNames);
  
  console.log(`Successfully generated ${modelNames.length} type definitions`);
}

/**
 * Generate TypeScript interface for a model
 */
async function generateModelInterface(modelName: string, model: ModelCtor<Model>) {
  console.log(`Processing model: ${modelName}`);
  
  // Get model attributes
  const attributes = model.getAttributes();
  
  // Start building interface
  let interfaceContent = `${CONFIG.fileHeader}export interface ${modelName} {\n`;
  
  // Add attributes
  for (const [attrName, attribute] of Object.entries(attributes)) {
    // Get TypeScript type from Sequelize type
    const tsType = getTypeScriptType(attribute.type.toString());
    const isOptional = attribute.allowNull ? '?' : '';
    
    // Add comment for attribute if available
    if (attribute.comment) {
      interfaceContent += `  /**\n   * ${attribute.comment}\n   */\n`;
    }
    
    // Add attribute definition
    interfaceContent += `  ${attrName}${isOptional}: ${tsType};\n`;
  }
  
  // Close interface
  interfaceContent += '}\n';
  
  // Write interface file
  const filePath = path.join(CONFIG.outputDir, `${modelName}.ts`);
  fs.writeFileSync(filePath, interfaceContent);
  
  console.log(`Generated interface for ${modelName}`);
}

/**
 * Generate index file with exports for all interfaces
 */
function generateIndexFile(modelNames: string[]) {
  let indexContent = CONFIG.fileHeader;
  
  // Add exports for each model
  for (const modelName of modelNames) {
    indexContent += `export type { ${modelName} } from './${modelName}';\n`;
  }
  
  // Write index file
  const indexPath = path.join(CONFIG.outputDir, 'index.ts');
  fs.writeFileSync(indexPath, indexContent);
  
  console.log('Generated index file for types');
}

/**
 * Convert Sequelize type to TypeScript type
 */
function getTypeScriptType(sequelizeType: string): string {
  const typeMap: Record<string, string> = {
    'INTEGER': 'number',
    'BIGINT': 'number',
    'FLOAT': 'number',
    'DOUBLE': 'number',
    'DECIMAL': 'number',
    'STRING': 'string',
    'TEXT': 'string',
    'CHAR': 'string',
    'UUID': 'string',
    'BOOLEAN': 'boolean',
    'DATE': 'Date',
    'DATEONLY': 'string',
    'TIME': 'string',
    'JSON': 'Record<string, any>',
    'JSONB': 'Record<string, any>',
    'ARRAY': 'any[]',
  };
  
  // Check for array types
  if (sequelizeType.includes('ARRAY')) {
    const baseType = sequelizeType.match(/ARRAY\((\w+)\)/)?.[1];
    if (baseType && typeMap[baseType]) {
      return `${typeMap[baseType]}[]`;
    }
    return 'any[]';
  }
  
  // Check for enum types
  if (sequelizeType.includes('ENUM')) {
    const enumValues = sequelizeType.match(/ENUM\((.*)\)/)?.[1];
    if (enumValues) {
      return enumValues
        .split(',')
        .map(v => v.trim().replace(/'/g, '"'))
        .join(' | ');
    }
    return 'string';
  }
  
  // Use mapped type or default to any
  return typeMap[sequelizeType] || 'any';
}

// Run the generator
generateTypes()
  .then(() => {
    console.log('Type generation completed successfully');
    process.exit(0);
  })
  .catch((error) => {
    console.error('Error generating types:', error);
    process.exit(1);
  });
